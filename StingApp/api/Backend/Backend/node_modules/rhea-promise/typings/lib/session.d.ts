import { Connection } from "./connection";
import { Receiver, ReceiverOptions } from "./receiver";
import { Sender, SenderOptions } from "./sender";
import { SessionEvents, AmqpError, Session as RheaSession } from "rhea";
import { OnAmqpEvent } from "./eventContext";
import { Entity } from "./entity";
/**
 * Describes the event listeners that can be added to the Session.
 * @interface Session
 */
export declare interface Session {
    on(event: SessionEvents, listener: OnAmqpEvent): this;
}
/**
 * Describes the session that wraps the rhea session.
 * @class Session
 */
export declare class Session extends Entity {
    private _session;
    private _connection;
    constructor(connection: Connection, session: RheaSession);
    /**
     * @property {Connection} connection The underlying AMQP connection.
     * @readonly
     */
    readonly connection: Connection;
    readonly outgoing: any;
    readonly error: AmqpError | Error | undefined;
    /**
     * Determines whether the session and the underlying connection is open.
     * @returns {boolean} result `true` - is open; `false` otherwise.
     */
    isOpen(): boolean;
    /**
     * Determines whether the close from the peer is a response to a locally initiated close request.
     * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
     */
    isClosed(): boolean;
    /**
     * Determines whether both local and remote endpoint for just the session itself are closed.
     * Within the "session_close" event handler, if this method returns `false` it means that
     * the local end is still open. It can be useful to determine whether the close
     * was initiated locally under such circumstances.
     *
     * @returns {boolean} `true` - closed, `false` otherwise.
     */
    isItselfClosed(): boolean;
    remove(): void;
    begin(): void;
    /**
     * Closes the amqp session.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "session_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_error" event while trying
     * to close an amqp session.
     */
    close(): Promise<void>;
    /**
     * Creates an amqp receiver on this session.
     * @param {Session} session The amqp session object on which the receiver link needs to be established.
     * @param {ReceiverOptions} [options] Options that can be provided while creating an amqp receiver.
     * @return {Promise<Receiver>} Promise<Receiver>
     * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
     * to create an amqp receiver or the operation timeout occurs.
     */
    createReceiver(options?: ReceiverOptions): Promise<Receiver>;
    /**
     * Creates an amqp sender on this session.
     * @param {SenderOptions} [options] Options that can be provided while creating an amqp sender.
     * @return {Promise<Sender>} Promise<Sender>
     * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
     * to create an amqp sender or the operation timeout occurs.
     */
    createSender(options?: SenderOptions): Promise<Sender>;
    /**
     * Adds event listeners for the possible events that can occur on the session object and
     * re-emits the same event back with the received arguments from rhea's event emitter.
     * @private
     * @returns {void} void
     */
    private _initializeEventListeners;
}
