"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const log = require("./log");
const constants_1 = require("./util/constants");
const amqp_common_1 = require("@azure/amqp-common");
const managementClient_1 = require("./managementClient");
const rhea_promise_1 = require("rhea-promise");
var ConnectionContext;
(function (ConnectionContext) {
    const userAgent = "/js-event-hubs";
    function getUserAgent(options) {
        const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;
        if (finalUserAgent.length > amqp_common_1.Constants.maxUserAgentLength) {
            throw new Error(`The user-agent string cannot be more than 128 characters in length.` +
                `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`);
        }
        return finalUserAgent;
    }
    ConnectionContext.getUserAgent = getUserAgent;
    function create(config, options) {
        if (!options)
            options = {};
        const parameters = {
            config: config,
            tokenProvider: options.tokenProvider,
            dataTransformer: options.dataTransformer,
            isEntityPathRequired: true,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: getUserAgent(options),
                version: constants_1.packageJsonInfo.version
            }
        };
        // Let us create the base context and then add EventHub specific ConnectionContext properties.
        const connectionContext = amqp_common_1.ConnectionContextBase.create(parameters);
        connectionContext.wasConnectionCloseCalled = false;
        connectionContext.senders = {};
        connectionContext.receivers = {};
        const mOptions = {
            address: options.managementSessionAddress,
            audience: options.managementSessionAudience
        };
        connectionContext.managementSession = new managementClient_1.ManagementClient(connectionContext, mOptions);
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = (context) => {
            connectionContext.wasConnectionCloseCalled = false;
            log.context("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionError = context.connection && context.connection.error
                ? context.connection.error
                : undefined;
            if (connectionError) {
                log.error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, connectionError);
            }
            const contextError = context.error;
            if (contextError) {
                log.error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, contextError);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numSenders: Object.keys(connectionContext.senders).length,
                numReceivers: Object.keys(connectionContext.receivers).length
            };
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was atleast one sender/receiver link on the connection before it went down.
            log.error("[%s] state: %O", connectionContext.connection.id, state);
            if (!state.wasConnectionCloseCalled && (state.numSenders || state.numReceivers)) {
                log.error("[%s] connection.close() was not called from the sdk and there were some " +
                    "sender or receiver links or both. We should reconnect.", connectionContext.connection.id);
                yield amqp_common_1.delay(amqp_common_1.Constants.connectionReconnectDelay);
                // reconnect senders if any
                for (const senderName of Object.keys(connectionContext.senders)) {
                    const sender = connectionContext.senders[senderName];
                    if (!sender.isConnecting) {
                        log.error("[%s] calling detached on sender '%s' with address '%s'.", connectionContext.connection.id, sender.name, sender.address);
                        sender.detached().catch((err) => {
                            log.error("[%s] An error occurred while reconnecting the sender '%s' with adress '%s' %O.", connectionContext.connection.id, sender.name, sender.address, err);
                        });
                    }
                    else {
                        log.error("[%s] sender '%s' with address '%s' is already reconnecting. Hence not " +
                            "calling detached on the sender.", connectionContext.connection.id, sender.name, sender.address);
                    }
                }
                // reconnect receivers if any
                for (const receiverName of Object.keys(connectionContext.receivers)) {
                    const receiver = connectionContext.receivers[receiverName];
                    if (!receiver.isConnecting) {
                        log.error("[%s] calling detached on receiver '%s' with address '%s'.", connectionContext.connection.id, receiver.name, receiver.address);
                        receiver.detached().catch((err) => {
                            log.error("[%s] An error occurred while reconnecting the receiver '%s' with adress '%s' %O.", connectionContext.connection.id, receiver.name, receiver.address, err);
                        });
                    }
                    else {
                        log.error("[%s] receiver '%s' with address '%s' is already reconnecting. Hence not " +
                            "calling detached on the receiver.", connectionContext.connection.id, receiver.name, receiver.address);
                    }
                }
            }
        });
        // Add listeners on the connection object.
        connectionContext.connection.on(rhea_promise_1.ConnectionEvents.connectionOpen, onConnectionOpen);
        connectionContext.connection.on(rhea_promise_1.ConnectionEvents.disconnected, disconnected);
        log.context("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext = exports.ConnectionContext || (exports.ConnectionContext = {}));
//# sourceMappingURL=connectionContext.js.map